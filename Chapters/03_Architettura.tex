\chapter{Architettura di un sistema operativo}
Un principio importante \`e la separazione tra meccanismi e criteri o policy: i primi determinano come eseguire qualcosa, mentre i secondi cosa si deve fare. Questa distinzione \`e importante ai fini della
flessibilit\`a in quanto i criteri sono soggetti a cambiamenti di luogo e tempo. Questi cambiamenti devono richiedere il cambio di meccanismi solo nel caso pessimo. Le principali tipologie di architettura di sistemi operativi sono:
\begin{itemize}
	\item Sistemi monolitici.
	\item Sistemi a struttura semplice: si ha un minimo di gerarchia e di struttura, non esiste  ancora la suddivisione modalità utente e modalità kernel.
	\item Sistema operativo a livelli.
	\item Sistemi basati su kernel: tutti i sistemi operativi adesso oscurano il kernel, ma tendono a mettere tutto in esso. Facendo così però se c’è un bug o un virus in uno di questi moduli, essi avranno gli stessi privilegi di
		altri moduli nel kernel. Per questo si usano sistemi basati su micro-kernel dove si tengono solo le funzioni principali come comunicazioni tra processi, scheduler e gestione della memoria principale. Tutto il resto è 
		gestito fuori come I/O o file system. I vantaggi sono maggiore portabilità e una più bassa probabilità di avere bug, ma uno dei difetti sono le scarse prestazioni. I microkernel pertanto si diffondono quando l’hardware 
		diventa molto performante, quindi questo calo di prestazioni non si percepisce nemmeno.
\end{itemize}
\section{macchinee virtuali}
Quando si parla di sistemi operativi è importante anche parlare di macchine virtuali, la prima viene diffusa da IBM. Ci sono diversi modi per implementare una virtual machine e i due principali sono TYPE1 e TYPE2. 
Le virtual machine sono completamente isolate, quindi non interagiscono con le altre virtual machine, sono utili quando scaricando qualcosa dalla rete si rischia di incontrare un virus. Nel sistema client-server tutte le funzionalità del 
sistema operativo sono implementate come fossero dei server, quindi i processi si interfacciano ad esse come fossero dei client. Una cospicua parte dei sistemi operativi è scritta in ASSEMBLER, mentre le parti relative al file system ad 
esempio sono scritte in C o C++. 
\section{Processi e thread}
Attributi (Process Control Block): contiene un puntatore alla cella di memoria che contiene l’immagine, contiene lo stato del processo in un determinato momento, contiene i registri, le informazioni relative allo stato dell’I/O. 
Un processo può essere in diversi stati. 
All’inizio il processo viene creato, poi può essere in esecuzione se gli viene assegnata la CPU o non in esecuzione se non gli viene assegnata la CPU. Il Dispatcher assegna la CPU ai processi che sono pronti, ma non in esecuzione (posso 
avere diversi processi in memoria, ma solo uno per volta usa la CPU e quindi è effettivamente in esecuzione, a meno di CPU multicore). Quando un processo è pronto e viene creato viene messo nella ReadyQueue (oppure nella coda di un 
dispositivo cioè la coda in cui viene messo un processo che sta aspettando di accedere a un determinato dispositivo). In realtà esistono diverse code in cui può essere messo un processo. Dispatch e Scheduler sono due componenti diversi, 
lo scheduler sceglie mentre il dispatcher implementa questa cosa. Context-Switch: salvo tutto quello che c’era nel PCB, tutto quello che stavo utilizzando al momento dell’esecuzione. Due operazioni fondamentali che fa un sistema operativo
è la creazione e la terminazione del processo. Ogni processo può creare altri processi e questi prendono il nome di processi figli. Il figlio può essere creato in modalità sincrona, cioè finché il figlio è in vita io non faccio niente, 
oppure in modalità asincrona cioè io creo il figlio e continuo la mia esecuzione. Con la fork il figlio lo creo esattamente uguale al padre, con la exec posso caricare sul figlio un programma diverso rispetto al padre. Con la wait creo 
un’esecuzione sincrona tra padre e figlio. Una fork può fallire perché o il padre non ha abbastanza memoria o perché non ha i privilegi per creare un figlio. L’exec cambia l’immagine in memoria del figlio. 
